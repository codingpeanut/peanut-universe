## **第七章重點整理：死鎖 (Deadlocks)**

### 7.1 定義 (Definition)

*   **死鎖 (Deadlocks)** 簡介：死鎖是指一組程序因互相等待對方持有的資源而無法繼續執行的情況。
*   作業系統通常不會處理死鎖。

### 7.2 系統模型 (System Model)

*   系統資源模型：
    *   資源類型 (Resource types)： `R1, R2, ..., Rm` 
        *   例如：CPU 週期、記憶體空間、I/O 設備
    *   每種資源類型 `Ri` 有 `Wi` 個實例 (instances)。
*   程序使用資源的步驟：
    *   請求 (request)
    *   使用 (use)
    *   釋放 (release)

### 7.3 死鎖的特性 (Deadlock Characterization)

*   **死鎖發生的四個必要條件**：
    1.  **互斥 (Mutual exclusion)**：一次只有一個程序可以使用一個資源。
    2.  **持有並等待 (Hold and wait)**：一個程序持有一個或多個資源，同時又在等待其他程序持有的資源。
    3.  **不可搶占 (No preemption)**：資源只能由持有它的程序自願釋放，在該程序完成其任務之後。
    4.  **循環等待 (Circular wait)**：存在一組等待程序 `{P0, P1, ..., Pn}`，其中 `P0` 等待 `P1` 持有的資源，`P1` 等待 `P2` 持有的資源，...，`Pn-1` 等待 `Pn` 持有的資源，而 `Pn` 等待 `P0` 持有的資源。

### 7.4 死鎖的處理方法 (Methods for Handling Deadlocks)

*   主要有三種處理死鎖的方法：
    1.  **死鎖預防 (Deadlock prevention)**：確保系統永遠不會進入死鎖狀態。
    2.  **死鎖避免 (Deadlock avoidance)**：允許系統進入死鎖狀態，然後再進行恢復。
    3.  **死鎖忽略 (Deadlock ignorance)**：忽略死鎖問題，假裝系統中從未發生過死鎖；大多數作業系統（包括 UNIX）都使用這種方法。

### 7.5 死鎖預防 (Deadlock Prevention)

*   **針對死鎖的四個必要條件，可以採取以下措施來預防死鎖**:
    1.  **互斥**: 對於可共享資源，不需要互斥；但對於不可共享資源，則必須滿足互斥條件。
    2.  **持有並等待**: 可以要求程序在開始執行之前一次性請求並分配所有需要的資源，或者只允許程序在沒有持有任何資源時才請求資源。 這種方法可能會導致資源利用率低和程序飢餓 (starvation)。
    3.  **不可搶占**: 如果一個持有某些資源的程序請求另一個無法立即分配給它的資源，則釋放該程序當前持有的所有資源。 這些被搶占的資源將被添加到程序等待資源列表中。 只有當程序能夠重新獲得其舊資源以及它正在請求的新資源時，才會重新啟動該程序。
    4.  **循環等待**: 對所有資源類型施加一個全序，並要求每個程序按照遞增的順序請求資源。 這樣可以避免循環等待的發生。

### 7.6 死鎖避免 (Deadlock Avoidance)

*   死鎖避免需要系統具備一些額外的先驗資訊，例如每個程序所需的最大資源數量。
*   **安全狀態 (Safe state)**：如果存在一個所有程序的序列 `<P1, P2, ..., Pn>`，使得對於每個 `Pi`，`Pi` 仍然可以請求的資源可以由當前可用資源加上所有 `j < i` 的 `Pj` 持有的資源滿足，則系統處於安全狀態。
    *   換句話說，如果 `Pi` 的資源需求不能立即滿足，那麼 `Pi` 可以等待所有 `Pj` 完成。
    *   當 `Pj` 完成後，`Pi` 可以獲得所需的資源，執行，返回分配的資源，然後終止。
    *   當 `Pi` 終止後，`Pi+1` 可以獲得其所需的資源，依此類推。
*   死鎖避免的目標是確保系統永遠不會進入不安全狀態。

### 7.7 死鎖檢測 (Deadlock Detection)

*   允許系統進入死鎖狀態。
*   使用死鎖檢測演算法來定期檢查系統中是否存在死鎖。
*   如果檢測到死鎖，則需要採取死鎖恢復方案來解決死鎖。

### 7.8 從死鎖中恢復 (Recovery from Deadlock)

*   **終止程序 (Process termination)**：
    *   中止所有死鎖程序。
    *   一次中止一個程序，直到消除死鎖循環。
    *   中止程序的順序需要考慮多種因素，例如程序的優先級、已執行的時間、已使用的資源等。
*   **資源搶占 (Resource preemption)**：
    *   選擇一個受害者程序，並搶占其資源。
    *   將系統回滾到某個安全狀態。
    *   重新啟動受害者程序。
    *   需要注意避免飢餓現象，即同一個程序總是作為受害者被選中。

### 考題預測

1.  解釋死鎖的四個必要條件，並說明如何利用這些條件來預防死鎖。
2.  什麼是安全狀態？為什麼在死鎖避免中要確保系統處於安全狀態？
3.  比較死鎖預防、死鎖避免和死鎖檢測三種處理死鎖的方法。
4.  解釋銀行家演算法的原理，並說明如何使用它來避免死鎖。
5.  討論從死鎖中恢復的策略，並說明選擇受害者程序時需要考慮哪些因素。

### 重點整理

*   **死鎖的四個必要條件是理解和處理死鎖的基礎。**
*   **死鎖預防、死鎖避免和死鎖檢測是處理死鎖的三種主要方法，各有優缺點。**
*   **銀行家演算法是一種常用的死鎖避免演算法。**
*   **從死鎖中恢復需要選擇受害者程序並進行資源搶占或程序終止。** 
