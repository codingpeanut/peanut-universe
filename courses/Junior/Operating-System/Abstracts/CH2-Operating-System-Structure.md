# CH2 - Operating System Structure

### 一、作業系統服務 (Operating System Services)

*   **使用者介面 (User Interface):** 作業系統提供使用者介面讓使用者與系統互動，常見的介面類型包括命令列介面 (CLI)、圖形使用者介面 (GUI)、觸控式螢幕介面和批次介面。
*   **程式執行 (Program Execution):** 作業系統負責將程式載入記憶體並執行，同時處理程式的正常結束或異常終止。
*   **輸入/輸出操作 (I/O Operations):** 作業系統管理程式的輸入/輸出操作，包括檔案和裝置的存取。
*   **檔案系統管理 (File-system Manipulation):** 作業系統提供檔案系統的管理功能，例如讀寫檔案、建立和刪除目錄、搜尋檔案和設定權限等。
*   **通訊 (Communications):** 作業系統提供程序間通訊的機制，讓程序可以在同一台電腦或透過網路交換訊息。
*   **錯誤偵測 (Error Detection):** 作業系統需要持續監控系統中可能發生的錯誤，並採取適當的措施確保系統的正確性和一致性。
*   **資源分配 (Resource Allocation):** 當多個使用者或多個工作同時執行時，作業系統需要將資源分配給每個使用者或工作，例如 CPU 週期、主記憶體、檔案儲存空間和輸入/輸出裝置。
*   **記錄 (Logging):** 作業系統需要記錄每個使用者使用了哪些電腦資源、使用量和使用類型。
*   **保護和安全 (Protection and Security):** 作業系統需要保護系統資源的安全性，防止未經授權的存取和惡意攻擊。

### 二、系統呼叫 (System Calls)

*   **定義和目的:** 系統呼叫是程式用來請求作業系統服務的介面，通常以高階語言 (例如 C 或 C++) 撰寫。
*   **API 的角色:** 程式通常透過應用程式介面 (API) 來間接使用系統呼叫，這樣可以簡化程式開發的複雜度。
*   **常見的 API:** 常見的 API 包括 Windows 的 Win32 API、基於 POSIX 系統 (包括 Unix、Linux 和 Mac OS X) 的 POSIX API，以及 Java 虛擬機器的 Java API。
*   **系統呼叫的實作:** 系統呼叫通常以數字編號，作業系統核心會根據編號執行對應的系統呼叫。
*   **參數傳遞:** 程式可以透過多種方式將參數傳遞給系統呼叫，例如使用暫存器、記憶體區塊或堆疊。
*   **系統呼叫的類型:** 常見的系統呼叫類型包括程序控制、檔案管理、裝置管理、資訊維護、通訊和保護。
![](https://github.com/codingpeanut/peanut-universe/blob/c262be2b036bd5e9e3b30d4b4a33d6aaf9399e4a/courses/Junior/Operating-System/Abstracts/assets/IMG_2786.jpeg)

### 三、系統程式 (System Programs)

*   **定義和目的:** 系統程式提供方便的環境讓使用者開發和執行程式，例如檔案管理、狀態資訊、程式語言支援、程式載入和執行、通訊、背景服務和應用程式。
*   **與系統呼叫的關係:** 一些系統程式只是系統呼叫的使用者介面，而另一些系統程式則更為複雜。
*   **常見的系統程式類型:** 系統程式包括檔案管理程式、狀態資訊程式、檔案修改程式、程式語言支援程式、程式載入和執行程式、通訊程式和背景服務程式。

### 四、連結器和載入器 (Linkers and Loaders)

*   **連結器:** 連結器將多個可重定位的目標檔案組合成一個可執行的二進制檔案，並連結所需的程式庫。
*   **載入器:** 載入器將可執行檔案載入到記憶體中，並進行重定位，將程式的各個部分分配到最終的記憶體地址。
*   **動態連結程式庫:** 現代作業系統通常使用動態連結程式庫 (DLL)，在程式執行時動態載入所需的程式庫，提高程式碼的重複使用率。
![](https://github.com/codingpeanut/peanut-universe/blob/20acabc506ef3c45fd75e575e24656f2a8ba0fd3/courses/Junior/Operating-System/Abstracts/assets/IMG_2798.jpeg)

### 五、作業系統設計與實作 (Design and Implementation)

*   **設計目標:** 作業系統的設計目標包括使用者目標 (例如易用性、可靠性和安全性) 和系統目標 (例如易於設計、實作和維護)。
*   **策略與機制:** 作業系統設計的一個重要原則是將策略與機制分離，這樣可以提高系統的靈活性。
*   **實作語言:** 作業系統的實作語言通常是 C 或 C++，但也可能使用其他語言，例如組合語言和腳本語言。

### 六、作業系統結構 (Operating System Structure)

*   **單一結構 (Monolithic Structure):** 單一結構的作業系統將所有功能都整合到一個單一的程式碼庫中，例如早期的 MS-DOS 和 Unix。
*   **分層結構 (Layered Approach):** 分層結構的作業系統將系統劃分為多個層次，每一層都建立在較低層次之上，例如 THE 作業系統。
*   **微核心結構 (Microkernel Structure):** 微核心結構的作業系統將核心功能最小化，將大部分功能移至使用者空間，例如 Mach 和 Mac OS X 核心 (Darwin)。
*   **模組化結構 (Modular Approach):** 模組化結構的作業系統允許動態載入核心模組，例如 Linux 和 Solaris。
*   **混合結構 (Hybrid Systems):** 混合結構的作業系統結合了多種結構方法，例如 Linux、Solaris、Windows 和 Mac OS X。

### 七、作業系統建置與開機 (Building and Booting an Operating System)

*   **建置流程:** 建置作業系統的流程包括撰寫程式碼、配置系統、編譯程式碼、安裝系統和開機系統。
*   **開機流程:** 開機流程包括啟動 BIOS 或 UEFI、載入開機載入程式、載入核心和啟動系統。

### 八、作業系統除錯 (Operating System Debugging)

*   **除錯方法:** 作業系統除錯可以使用日誌檔案、核心傾印檔案和效能調校工具。
*   **效能調校:** 效能調校可以使用追蹤和分析工具來找出系統瓶頸並改善效能。
*   **BCC 工具:** BCC (BPF Compiler Collection) 是一個提供 Linux 追蹤功能的工具包，例如 disksnoop.py 可以追蹤磁碟輸入/輸出活動。

### 九、其他重要概念

*   **應用程式二進制介面 (ABI):** ABI 定義了二進制程式碼的不同元件如何在特定的作業系統和架構上互動。
*   **虛擬機器 (VM):** 虛擬機器可以模擬不同的硬體環境，讓作業系統在非原生硬體上執行。
