# CH4 - Multithreaded Programming

### 一、緒論

* 現代應用程式大多為**多執行緒**的。
* **執行緒**在應用程式內執行，允許應用程式內的**多個任務**由不同的執行緒執行。
    * 例如，一個應用程式可以同時更新顯示、擷取資料、執行拼寫檢查和回應網路請求。
* 程序建立是**重量級**的，而執行緒建立是**輕量級**的。
    * 執行緒建立和切換的開銷比程序建立和切換的開銷要小得多。
* 使用多執行緒可以簡化程式碼並提高效率。
* 核心通常也是多執行緒的。

### 二、多執行緒伺服器架構

* 圖示：多執行緒伺服器架構示意圖 (來源中沒有提供)

### 三、多執行緒的優點

* **回應性：** 如果程序的一部分被阻塞，多執行緒可以允許程序的其餘部分繼續執行，這對於使用者介面尤其重要。
* **資源共享：** 執行緒共享程序的資源，比共享記憶體或訊息傳遞更容易。
* **經濟性：** 執行緒建立比程序建立更便宜，執行緒切換的開銷也比上下文切換更低。
* **可擴展性：** 多執行緒程序可以利用多處理器架構。

### 四、多核心程式設計

* 多核心或多處理器系統給程式設計師帶來了壓力，挑戰包括：
    * 如何劃分活動
    * 如何平衡負載
    * 如何分割資料
    * 如何處理資料依賴性
    * 如何測試和除錯多執行緒程式

* **平行性**意味著系統可以同時執行多個任務。 **並發性**支援多個任務同時取得進展。
    * 單個處理器/核心上的並發性是由排程器提供的。

* 平行性類型：
    * **資料平行性：** 將相同資料的子集分配到多個核心，每個核心執行相同的操作。
    * **任務平行性：** 將執行緒分配到多個核心，每個執行緒執行不同的操作。

* 隨著執行緒數量的增長，對執行緒的架構支援也在增長。
    * 現代 CPU 不僅具有多個核心，還具有硬體執行緒。
    * 例如，Oracle SPARC T4 具有 8 個核心，每個核心具有 8 個硬體執行緒。

### 五、並發性與平行性

* 單核心系統上的並發執行示意圖： (來源中沒有提供)
* 多核心系統上的平行性示意圖： (來源中沒有提供)

### 六、單執行緒和多執行緒程序

* 單執行緒程序示意圖： (來源中沒有提供)
* 多執行緒程序示意圖： (來源中沒有提供)

### 七、阿姆達爾定律

* 阿姆達爾定律**識別了在具有串列和並行元件的應用程式中，新增額外核心所帶來的效能提升**。
    * **S** 是串列部分的比例。
    * **N** 是處理器核心的數量。
    * 例如，如果應用程式有 75% 是並行的，25% 是串列的，那麼從 1 個核心增加到 2 個核心會使速度提高 1.6 倍。
    * 當 N 趨近於無限大時，加速比趨近於 1 / S。

* 應用程式的串列部分對新增額外核心所帶來的效能提升有**不成比例的影響**。
* 但阿姆達爾定律是否考慮了現代多核心系統？

### 八、使用者執行緒和核心執行緒

* **使用者執行緒**由使用者層級執行緒庫管理。
* 三個主要的執行緒庫：
    * POSIX Pthreads
    * Win32 執行緒
    * Java 執行緒

* **核心執行緒**由核心支援。
* 幾乎所有通用作業系統都支援核心執行緒，包括：
    * Windows
    * Solaris
    * Linux
    * Tru64 UNIX
    * Mac OS X

* 使用者執行緒和核心執行緒之間必須存在某種關係。

### 九、多執行緒模型

* 三種主要的多執行緒模型：
    * 多對一
    * 一對一
    * 多對多

#### 1. 多對一模型

* 將多個使用者層級執行緒映射到單個核心執行緒。
* 一個執行緒阻塞會導致所有執行緒阻塞。
* 多個執行緒可能無法在多核心系統上並行執行，因為一次只有一個執行緒可以在核心模式下執行。
* 目前很少有系統使用這種模型。
* 例子：
    * Solaris 綠色執行緒
    * GNU 可移植執行緒

#### 2. 一對一模型

* 每個使用者層級執行緒都映射到一個核心執行緒。
* 建立使用者層級執行緒會建立一個核心執行緒。
* 比多對一模型具有更高的並發性。
* 由於開銷，每個程序的執行緒數量有時會受到限制。
* 例子：
    * Windows NT/XP/2000
    * Linux
    * Solaris 9 及更高版本

#### 3. 多對多模型

* 允許多個使用者層級執行緒映射到多個核心執行緒。
* 允許作業系統建立足夠數量的核心執行緒。
* 例子：
    * Solaris 9 以前的版本
    * Windows NT/2000 with the ThreadFiber package

#### 4. 兩級模型

* 類似於多對多模型，但它允許使用者執行緒綁定到核心執行緒。
* 例子：
    * IRIX
    * HP-UX
    * Tru64 UNIX
    * Solaris 8 及更早版本

### 十、執行緒庫

* **執行緒庫**為程式設計師提供了用於建立和管理執行緒的 API。
* 實現執行緒庫的兩種主要方法：
    * 庫完全在使用者空間中
    * 由作業系統支援的核心層級庫

#### 1. Pthreads

* Pthreads 可以作為使用者層級或核心層級提供。
* 它是用於執行緒建立和同步的 POSIX 標準 (IEEE 1003.1c) API。
* 它是一個**規範，而不是實現**。
    * API 指定了執行緒庫的行為，而實現則由執行緒庫的開發者決定。

* Pthreads 常見於 UNIX 作業系統 (Solaris、Linux、Mac OS X)。
* Pthreads 示例： (來源中提供了程式碼示例)

#### 2. Win32 API

* Win32 API 示例： (來源中提供了程式碼示例)

#### 3. Java 執行緒

* Java 執行緒由 JVM 管理。
* 通常使用底層作業系統提供的執行緒模型來實現。
* 建立 Java 執行緒的方法：
    * 擴展 Thread 類別
    * 實現 Runnable 介面

* Java 多執行緒程式示例： (來源中提供了程式碼示例)

### 十一、隱式執行緒

* 隨著執行緒數量的增加，程式正確性在顯式執行緒中變得更加困難，因此隱式執行緒越來越流行。
* 執行緒的建立和管理由編譯器和執行時庫完成，而不是程式設計師。
* 隱式執行緒的三種方法：
    * 執行緒池
    * OpenMP
    * Grand Central Dispatch

* 其他方法包括：
    * Microsoft Threading Building Blocks (TBB)
    * java.util.concurrent 套件

#### 1. 執行緒池

* 在池中建立多個執行緒，它們在池中等待工作。
* 優點：
    * 使用現有執行緒處理請求通常比建立新執行緒稍快。
    * 允許將應用程式中的執行緒數量限制為池的大小。
    * 將要執行的任務與建立任務的機制分離，允許使用不同的策略來執行任務。
        * 例如，可以將任務排程為定期執行。

* Windows API 支援執行緒池。

#### 2. OpenMP

* OpenMP 是一組針對 C、C++ 和 FORTRAN 的編譯器指令和 API。
* 它為共享記憶體環境中的平行程式設計提供支援。
* 它識別平行區域——可以並行執行的程式碼塊。
    * `#pragma omp parallel`：建立與核心數量相同的執行緒。
    * `#pragma omp parallel for`：並行執行 for 迴圈。

#### 3. Grand Central Dispatch

* Grand Central Dispatch 是 Apple 為 Mac OS X 和 iOS 作業系統開發的技術。
* 它是對 C 和 C++ 語言、API 和執行時庫的擴展。
* 它允許識別平行部分。
* 它管理執行緒的大部分細節。
* **程式碼塊**用 `^{ }` 表示。
    * 例如：`^{ printf("我是一個程式碼塊"); }`

* 程式碼塊被放置在**派送佇列**中。
    * 當程式碼塊從佇列中移除時，它會被分配給執行緒池中可用的執行緒。

* 兩種類型的派送佇列：
    * **串列佇列：** 程式碼塊以 FIFO 順序移除，每個程序都有一個串列佇列，稱為**主佇列**。
        * 程式設計師可以在程式中建立額外的串列佇列。
    * **並發佇列：** 程式碼塊以 FIFO 順序移除，但可以同時移除多個程式碼塊。
        * 有三個系統級並發佇列，優先順序分別為低、預設和高。

### 十二、執行緒問題

* 多執行緒程式設計中的問題：
    * `fork()` 和 `exec()` 系統呼叫的語義
    * 信號處理
        * 同步和非同步信號
    * 目標執行緒的執行緒取消
        * 非同步或延遲取消
    * 執行緒局部儲存
    * 排程器啟動

#### 1. `fork()` 和 `exec()` 的語義

* `fork()` 是複製呼叫執行緒還是複製所有執行緒？
    * 一些 UNIX 系統有兩個版本的 `fork()`。

* `exec()` 通常正常工作——替換正在執行的程序，包括所有執行緒。

#### 2. 信號處理

* 在 UNIX 系統中，信號用於通知程序發生了特定事件。
* **信號處理程式**用於處理信號。
    1. 信號由特定事件產生。
    2. 信號被傳遞到一個程序。
    3. 信號由兩個信號處理程式之一處理：
        * 預設信號處理程式
        * 使用者定義的信號處理程式

* 每個信號都有一個預設處理程式，當核心處理信號時會執行該處理程式。
    * 使用者定義的信號處理程式可以覆蓋預設處理程式。

* 對於單執行緒程序，信號傳遞給程序。
* 對於多執行緒程序，信號應該傳遞到哪裡？
    * 將信號傳遞給信號適用的執行緒。
    * 將信號傳遞給程序中的每個執行緒。
    * 將信號傳遞給程序中的某些執行緒。
    * 指定一個特定執行緒來接收程序的所有信號。

#### 3. 執行緒取消

* **執行緒取消**是指在執行緒完成之前終止它。
* 要取消的執行緒稱為**目標執行緒**。
* 兩種主要的方法：
    * **非同步取消：** 立即終止目標執行緒。
    * **延遲取消：** 允許目標執行緒定期檢查是否應該取消。

* Pthreads 建立和取消執行緒的程式碼： (來源中提供了程式碼示例)

* 呼叫執行緒取消會請求取消，但實際取消取決於執行緒狀態。
* 如果執行緒禁用了取消，則取消將保持掛起狀態，直到執行緒啟用它為止。
* 預設類型是延遲取消。
    * 只有當執行緒到達**取消點**時才會發生取消。
        * 例如，`pthread_testcancel()`
        * 然後呼叫**清理處理程式**。

* 在 Linux 系統上，執行緒取消是透過信號處理的。

#### 4. 執行緒局部儲存

* **執行緒局部儲存 (TLS)** 允許每個執行緒擁有自己的資料副本。
* 當您無法控制執行緒建立過程時 (例如，使用執行緒池時)，TLS 很有用。
* TLS 不同於局部變數。
    * 局部變數僅在單個函數呼叫期間可見。
    * TLS 在函數呼叫之間可見。

* TLS 類似於靜態資料。
    * TLS 對每個執行緒都是唯一的。

#### 5. 排程器啟動

* 多對多模型和兩級模型都需要通信來維護分配給應用程式的適當數量核心執行緒。
* 通常在使用者執行緒和核心執行緒之間使用一個中間資料結構——**輕量級程序 (LWP)**。
    * LWP 看起來像是一個虛擬處理器，程序可以在其上排程使用者執行緒以供執行。
    * 每個 LWP 都附加到一個核心執行緒。
    * 應該建立多少個 LWP？

* **排程器啟動**提供**上呼叫**——一種從核心到執行緒庫中的上呼叫處理程式的通信機制。
* 這種通信允許應用程式維護正確數量的核心執行緒。

### 十三、作業系統示例

* 作業系統示例： 
    * Windows XP 執行緒
    * Linux 執行緒

#### 1. Windows 執行緒

* Windows 實現了 Windows API——Win 98、Win NT、Win 2000、Win XP 和 Win 7 的主要 API。 
* 它實現了一對一映射，核心層級執行緒。 
* 每個執行緒包含： 
    * 執行緒 ID
    * 表示處理器狀態的暫存器集
    * 當執行緒在使用者模式或核心模式下執行時，分別使用使用者堆疊和核心堆疊
    * 由執行時庫和動態連結庫 (DLL) 使用的私有資料儲存區

* 暫存器集、堆疊和私有資料儲存區稱為執行緒的**上下文**。 

* 執行緒的主要資料結構包括： 
    * **ETHREAD (執行緒區塊)：** 包括指向執行緒所屬程序的指標和指向 KTHREAD 的指標，位於核心空間中。 
    * **KTHREAD (核心執行緒區塊)：** 排程和同步資訊、核心模式堆疊、指向 TEB 的指標，位於核心空間中。 
    * **TEB (執行緒環境區塊)：** 執行緒 ID、使用者模式堆疊、執行緒局部儲存，位於使用者空間中。 

* Windows XP 執行緒資料結構示意圖： (來源中提供了示意圖) 

#### 2. Linux 執行緒

* Linux 將執行緒稱為**任務**，而不是執行緒。 
* 執行緒建立是透過 `clone()` 系統呼叫完成的。 
* `clone()` 允許子任務共享父任務 (程序) 的地址空間。 
    * 標誌控制行為。 

* `struct task_struct` 指向程序資料結構 (共享或唯一)。 
