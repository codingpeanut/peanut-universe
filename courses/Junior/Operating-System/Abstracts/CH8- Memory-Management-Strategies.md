## **第八章重點整理：記憶體管理策略 (Memory Management Strategies)**

###  背景 (Background)

*   程式必須先從硬碟載入到記憶體中，並放置在一個程序中才能運行。
*   主記憶體和暫存器是 CPU 唯一可以直接存取的儲存空間。
*   記憶體單元只能看到地址流 + 讀取請求，或地址 + 數據和寫入請求。
*   暫存器訪問時間為一個 CPU 時脈週期（或更短）。
*   主記憶體訪問可能需要許多週期，導致 CPU 停滯。
*   **高速緩衝記憶體 (Cache)** 位於主記憶體和 CPU 暫存器之間。
*   需要保護記憶體以確保正確操作。

###  地址綁定 (Address Binding)

*   地址綁定是指將指令和數據綁定到記憶體地址的過程，可以在三個不同階段進行：
    *   **編譯時間 (Compile time)**：如果事先知道記憶體位置，則可以生成絕對代碼。如果起始位置發生變化，則必須重新編譯代碼。
    *   **載入時間 (Load time)**：如果在編譯時不知道記憶體位置，則必須生成可重定位的代碼。
    *   **執行時間 (Execution time)**：如果程序在其執行期間可以從一個記憶體區段移動到另一個記憶體區段，則綁定會延遲到執行時。 
        *   需要硬體支援地址映射（例如基址和限址暫存器）。

###  邏輯地址與物理地址空間 (Logical vs. Physical Address Space)

*   邏輯地址空間的概念與獨立的物理地址空間的綁定對於正確的記憶體管理至關重要。
    *   **邏輯地址 (Logical address)**：由 CPU 生成，也稱為虛擬地址。
    *   **物理地址 (Physical address)**：記憶體單元看到的地址。
*   在編譯時間和載入時間地址綁定方案中，邏輯地址和物理地址是相同的；在執行時間地址綁定方案中，邏輯地址和物理地址不同。
*   **邏輯地址空間 (Logical address space)** 是程序生成的所有邏輯地址的集合。
*   **物理地址空間 (Physical address space)** 是程序生成的所有物理地址的集合。

###  記憶體管理單元 (Memory-Management Unit, MMU)

*   MMU 是一種硬體裝置，在執行時將虛擬地址映射到物理地址。
*   使用者程式處理邏輯地址，它永遠不會看到真正的物理地址。
*   執行時間綁定發生在引用記憶體位置時。
*   邏輯地址綁定到物理地址。

###  動態載入 (Dynamic Loading)

*   例程直到被調用時才載入。
*   更好的記憶體空間利用率；未使用的例程永遠不會被載入。
*   所有例程都以可重定位載入格式保存在磁碟上。
*   當需要大量代碼來處理不常發生的情況時非常有用。
*   不需要作業系統的特殊支援，透過程式設計實現。

###  動態連結 (Dynamic Linking)

*   **靜態連結 (Static linking)**：系統函式庫和程式代碼由載入器組合到二進制程式映像中。
*   **動態連結 (Dynamic linking)**：連結被推遲到執行時間。
*   使用一小段代碼 **存根 (Stub)** 來定位適當的記憶體駐留函式庫例程。
*   存根用例程的地址替換自身，並執行該例程。
*   作業系統檢查例程是否在程序的記憶體地址空間中。
    *   如果不在地址空間中，則添加到地址空間中。
*   動態連結對於函式庫特別有用。
*   系統也稱為 **共用函式庫 (Shared libraries)**。

###  交換 (Swapping)

*   程序可以暫時從記憶體中交換到後備儲存空間，然後再載入到記憶體中繼續執行。
    *   程序的總物理記憶體空間可以超過實際的物理記憶體。
*   **後備儲存空間 (Backing store)**：一種高速磁碟，其大小足以容納所有使用者所有記憶體映像的副本；必須提供對這些記憶體映像的直接存取。
*   交換時間的主要部分是傳輸時間；總傳輸時間與交換的記憶體量成正比。
*   系統維護一個就緒程序隊列，這些程序的記憶體映像儲存在磁碟上。
*   現代作業系統中不使用標準交換。
    *   但修改後的版本很常見，僅在可用記憶體極低時才進行交換。

###  行動系統上的交換 (Swapping on Mobile Systems)

*   行動系統通常不支援交換。
    *   基於快閃記憶體。
        *   空間量小。
        *   寫入次數有限。
        *   行動平台上快閃記憶體和主記憶體之間的吞吐量較差。
*   iOS 和 Android 使用其他方法來釋放記憶體，例如要求應用程式自願放棄已分配的記憶體或終止應用程式。

###  連續分配 (Contiguous Allocation)

*   主記憶體必須同時支援作業系統和使用者程序。
*   資源有限，必須有效分配。
*   連續分配是一種早期的記憶體分配方法。
*   主記憶體通常分為兩個分區：
    *   **常駐作業系統 (Resident operating system)**：通常位於低地址記憶體中，包含中斷向量。
    *   **使用者程序 (User processes)**：位於高地址記憶體中。
*   每個程序都包含在一個連續的記憶體區段中。

###  動態儲存分配問題 (Dynamic Storage-Allocation Problem)

*   當一個程序到達時，會從一個足夠大的空閒區塊中為其分配記憶體。
*   程序退出後會釋放其分區，相鄰的空閒分區會合併。
*   作業系統維護以下資訊：
    *   已分配的分區。
    *   空閒分區（空洞）。
*   有三種主要的動態儲存分配演算法：
    *   **首次適配 (First-fit)**：分配第一個足夠大的空閒區塊。
    *   **最佳適配 (Best-fit)**：分配最小的足夠大的空閒區塊；除非按大小排序，否則必須搜尋整個清單。
        *   產生最小的剩餘空閒區塊。
    *   **最差適配 (Worst-fit)**：分配最大的空閒區塊；也必須搜尋整個清單。
        *   產生最大的剩餘空閒區塊。

###  分頁 (Paging)

*   程序的物理地址空間可以是非連續的；只要物理記憶體可用，就會為程序分配物理記憶體。
    *   避免外部碎片。
    *   避免不同大小記憶體塊的問題。
*   將物理記憶體劃分為固定大小的塊，稱為 **頁框 (Frame)**。
*   將邏輯記憶體劃分為相同大小的塊，稱為 **頁面 (Page)**。
*   **頁表 (Page table)**：用於將邏輯地址轉換為物理地址。
*   仍然存在內部碎片。

###  頁表結構 (Structure of the Page Table)

*   使用直接方法，分頁的記憶體結構可能會變得非常龐大。
*   **分層分頁 (Hierarchical Paging)**：將邏輯地址空間分解為多個頁表。
    *   一種簡單的技術是 **兩級頁表 (Two-level page table)**。
    *   然後對頁表進行分頁。
*   **雜湊頁表 (Hashed Page Tables)**：將虛擬頁碼雜湊到一個頁表中。
*   **反向頁表 (Inverted Page Tables)**：追蹤所有物理頁面，而不是每個程序都有一個頁表並追蹤所有可能的邏輯頁面。

###  英特爾架構 (Intel Architectures)

*   奔騰 CPU 是 32 位元，稱為 IA-32 架構。
*   目前的英特爾 CPU 是 64 位元，稱為 IA-64 架構。
*   IA-32 架構支援分段和分段與分頁。
*   IA-64 架構提供更大的地址空間和更靈活的分頁方案。

###  ARM 架構 (ARM Architecture)

*   ARM 是行動平台晶片的霸主（例如 Apple iOS 和 Google Android 裝置）。
*   現代、節能的 32 位元 CPU。
*   支援不同大小的頁面和區段。
*   使用分層分頁和 TLB 來提高效能。

##  重點整理

*   記憶體管理對於作業系統的效能和穩定性至關重要。
*   地址綁定、邏輯地址和物理地址空間是記憶體管理的關鍵概念。
*   分頁和分段是兩種常用的記憶體管理技術。
*   頁表結構可以透過分層分頁、雜湊頁表和反向頁表來最佳化。
*   英特爾和 ARM 架構都採用了先進的記憶體管理技術。

##  考題預測

*   解釋地址綁定的概念及其不同階段。
*   比較邏輯地址和物理地址空間。
*   描述分頁和分段的優缺點。
*   說明不同類型的頁表結構，例如分層分頁、雜湊頁表和反向頁表。
*   比較英特爾和 ARM 架構中的記憶體管理技術。
